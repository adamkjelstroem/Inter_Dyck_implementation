


## 1. Overview

**Paper** : The Decidability and Complexity of Interleaved Bidirected Dyck Reachability, POPL'22

**Artifact Outline** - In the above paper, we present an algorithm for solving interleaved, bidirected $D_1 \odot D_1$ reachability in $O(n^3 \alpha(n))$, where a is the inverse Ackermann function.
We have implemented this algorithm along with techniques for pre-processing and simplifying input graphs and run it on Dacapo Benchmarks.

We also present an algorithm for solving interleaved, bidirected $D_1 \odot D_k$ reachability in $O(n^2 \alpha(n))$ with $O(n)$ bounded counters.
We have also implemented this algorithm along with pre-processing and simplification and run it on Dacapo Benchmarks.

We have implemented the algorithms in C++.

Here we describe how to run the implementations and obtain the results found in Table 2 of the paper.


## 2. Requirements

1. Machine with Unix based operating system, such as Ubuntu or MacOS. Our experiments were performed on a machine with about 8GB RAM. 
2. The g++ command line tool.

## 3. Directory Structure

```
root/
|--- README.md				This README 
|--- popl22-paper55.pdf     The associated paper.
|--- COPYING.txt	        License 
|--- benchmarks/	        The benchmark files in .dot format.
|--- build/	                The output folder.
|--- include/		        Header files for the C++ project.
|--- src/		        	Class files for the C++ project.

```

## 4. Benchmarks
As per standard in Dyck Reachability, the inputs to our artifact are directed graphs with edges annotated by labels of different parenthesis symbols.
These graphs are dependent on the abstraction and type of analysis to be run, and are not generated by our tool.
They can be produced using standard static analysis tools such as Soot and Wala.
Our experiments are graphs obtained from Dacapo benchmarks for a type of bidirected alias analysis.
Section 7 explains how to run the tool on custom benchmarks.

## 5. Source Code

The main algorithms are found in *src/graph/graph.cpp*. 

The primary function for computing $D_1 \odot D_1$ reachability is called ```bidirectedInterleavedD1D1Reach()```.

Similarly, the primary function for computing $D_1 \odot D_k$ reachability is called ```bidirectedInterleavedDkD1Reach()```.

## 6. Execution

The workflow for executing the artifact is pretty simple. Run the below commands in a terminal from the root of this project.


```
./compile.sh
build/main.out > table.tex 
```

This runs the $D_1 \odot D_1$ algorithm followed by the $D_1 \odot D_k$ algorithm and outputs the results in a file *table.tex*. 
The command runs within 10'-12' on our machine.

## 7. List of Claims

The experimental claims are made in Table 2 of the paper, which states
1. The running times of the new algorithms for $D_1 \odot D_1$ reachability (Section 3) and $D_1 \odot D_k$ reachability (Section 4.3) for each benchmark.
2. The number of Inter-Dyck Strongly Connected Components (ID-SCCs) and Dyck Strongly Connected Components (D-SCCs) in each benchmark.

The file *table.tex* produced with the above command contains Table 2 in the paper.


## 8. Custom Benchmarks

To run your own benchmarks, add your "\<benchmark\>.dot" files to this directory, then run 

```
build/main.out -b *space separated benchmark names* > table.tex
```

### Benchmark file structure

Each line in a ".dot" file corresponds to an edge. Example:

a->b[label="ob--23"]

Here, an edge from 'a' to 'b' labeled 'ob--23' is declared. There are four types of labels:

 - "ob--i": opening bracket with id $i$, i.e. $[_i$
 - "cb--i": closing bracket with id $i$, i.e. $]_i$
 - "op--i": opening parenthesis with id $i$, i.e. $(_i$
 - "cp--i": closing parenthesis with id $i$, i.e. $)_i$

Brackets and parentheses correspond to each of the Dyck languages. 

Any line without the "->" substring will be skipped.